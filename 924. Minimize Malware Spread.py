from typing import List
class UFS:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.sets = {i:[i] for i in range(n)}
    
    def find(self, p):
        if(p!=self.parent[p]):
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]
    
    def union(self, a, b):
        aroot = self.find(a)
        broot = self.find(b)
        if aroot!=broot:
            anodes = self.sets.pop(aroot)
            self.sets[broot].extend(anodes)
            self.parent[aroot] = broot
            
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        ufs = UFS(n)
        
        for i in range(n):
            for j in range(i,n):
                if graph[i][j] == 1:
                    ufs.union(i,j)
        ans = []
        for k,nodes in ufs.sets.items():
            tmp = []
            for node in nodes:
                if node in initial:
                    tmp.append(node)
            if len(tmp)==1:
                ans.append((len(nodes), tmp[0]))
        if not ans:
            return initial[0]
        ans.sort(key=lambda x: (-x[0],x[1]))
        return ans[0][1]
        
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
            
                
                
if __name__ == "__main__":
    graph = [[1,1,1],[1,1,1],[1,1,1]]
    initial = [1,2]
    Solution().minMalwareSpread(graph, initial)